<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>LLM VRAM Calculator</title>
	<style>
		:root {
			--primary: #2563eb;
			--primary-hover: #1d4ed8;
			--on-primary: #ffffff;
			--background: #f8fafc;
			--surface: #ffffff;
			--text: #0f172a;
			--text-muted: #64748b;
			--border: #e2e8f0;
			--input-bg: #f1f5f9;
			--success: #16a34a;
			--danger: #dc2626;
			--warning: #ea580c;
			--warning-bg: #ffedd5;
			--warning-text: #9a3412;
			--radius: 0.75rem;
		}

		@media (prefers-color-scheme: dark) {
			:root:not(.light) {
				--primary: #3b82f6;
				--primary-hover: #60a5fa;
				--on-primary: #ffffff;
				--background: #0f172a;
				--surface: #1e293b;
				--text: #f1f5f9;
				--text-muted: #94a3b8;
				--border: #334155;
				--input-bg: #0f172a;
				--success: #4ade80;
				--danger: #f87171;
				--warning: #fb923c;
				--warning-bg: #431407;
				--warning-text: #ffedd5;
			}
		}

		:root.dark {
			--primary: #3b82f6;
			--primary-hover: #60a5fa;
			--on-primary: #ffffff;
			--background: #0f172a;
			--surface: #1e293b;
			--text: #f1f5f9;
			--text-muted: #94a3b8;
			--border: #334155;
			--input-bg: #0f172a;
			--success: #4ade80;
			--danger: #f87171;
			--warning: #fb923c;
			--warning-bg: #431407;
			--warning-text: #ffedd5;
		}

		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			background: var(--background);
			color: var(--text);
			font-family: sans-serif;
			line-height: 1.5;
			min-height: 100vh;
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 2rem;
		}

		.container {
			width: 100%;
			max-width: 1200px;
			margin: 0 auto;
		}

		/* Header */
		.app-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 2rem;
			flex-wrap: wrap;
			gap: 1rem;
		}

		.title-group h1 {
			font-size: 1.875rem;
			font-weight: 800;
			color: var(--primary);
			letter-spacing: -0.025em;
		}

		.subtitle {
			color: var(--text-muted);
			font-size: 0.95rem;
			max-width: 600px;
		}

		.selectors {
			display: flex;
			gap: 0.75rem;
		}

		select {
			background: var(--surface);
			border: 1px solid var(--border);
			color: var(--text);
			padding: 0.5rem 2rem 0.5rem 1rem;
			border-radius: 0.5rem;
			font-size: 0.875rem;
			cursor: pointer;
			appearance: none;
			background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
			background-position: right 0.5rem center;
			background-repeat: no-repeat;
			background-size: 1.5em 1.5em;
		}

		select:focus {
			outline: 2px solid var(--primary);
			outline-offset: 1px;
			border-color: var(--primary);
		}

		/* Main Grid */
		.main-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 2rem;
			margin-bottom: 2rem;
		}

		.card {
			background: var(--surface);
			border-radius: var(--radius);
			border: 1px solid var(--border);
			padding: 1.5rem;
			margin-bottom: 1.5rem;
		}

		.card:last-child {
			margin-bottom: 0;
		}

		.card h2 {
			font-size: 1.125rem;
			font-weight: 700;
			margin-bottom: 1.25rem;
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		.form-group {
			margin-bottom: 1.5rem;
		}

		.form-group:last-child {
			margin-bottom: 0;
		}

		.label-row {
			display: flex;
			justify-content: space-between;
			margin-bottom: 0.5rem;
		}

		.label-row label {
			font-weight: 600;
			font-size: 0.9rem;
			color: var(--text);
		}

		.label-row .value {
			font-family: monospace;
			font-weight: 700;
			color: var(--primary);
		}

		/* Inputs */
		input[type="range"] {
			width: 100%;
			height: 6px;
			background: var(--border);
			border-radius: 3px;
			outline: none;
			-webkit-appearance: none;
		}

		input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 18px;
			height: 18px;
			background: var(--primary);
			border-radius: 50%;
			cursor: pointer;
			transition: transform 0.1s;
		}

		input[type="range"]::-webkit-slider-thumb:hover {
			transform: scale(1.1);
		}

		.slider-labels {
			display: flex;
			justify-content: space-between;
			font-size: 0.75rem;
			color: var(--text-muted);
			margin-top: 0.5rem;
		}

		select.full-width {
			width: 100%;
		}

		/* Results */
		.result-card {
			background: var(--surface);
			border-radius: var(--radius);
			border: 1px solid var(--border);
			padding: 2rem;
			text-align: center;
			margin-bottom: 1.5rem;
			position: sticky;
			top: 1rem;
			z-index: 10;
		}

		.result-value {
			font-size: 4rem;
			font-weight: 800;
			line-height: 1;
			color: var(--primary);
			margin: 0.5rem 0;
			letter-spacing: -0.05em;
		}

		.result-value.insufficient {
			font-size: 2.5rem;
			color: var(--danger);
		}

		.result-category {
			font-weight: 600;
			color: var(--text-muted);
			text-transform: uppercase;
			font-size: 0.75rem;
			letter-spacing: 0.05em;
		}

		.model-details {
			margin-top: 1.5rem;
			padding-top: 1rem;
			border-top: 1px solid var(--border);
			display: flex;
			justify-content: center;
			gap: 2rem;
		}

		.detail-item {
			display: flex;
			flex-direction: column;
		}

		.detail-item span:first-child {
			font-size: 0.75rem;
			color: var(--text-muted);
		}

		.detail-item span:last-child {
			font-weight: 700;
			font-size: 1.125rem;
		}

		/* Metrics */
		.metric-row {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 0.75rem 0;
			border-bottom: 1px solid var(--border);
		}

		.metric-row:last-child {
			border-bottom: none;
		}

		.metric-label {
			font-size: 0.9rem;
			color: var(--text-muted);
		}

		.metric-value-group {
			text-align: right;
		}

		.metric-val {
			font-weight: 700;
			font-family: monospace;
		}

		.metric-sub {
			font-size: 0.75rem;
			color: var(--text-muted);
			display: block;
		}

		/* Warning */
		.warning-box {
			background: var(--warning-bg);
			border: 1px solid var(--warning);
			color: var(--warning-text);
			padding: 1rem;
			border-radius: var(--radius);
			margin-bottom: 1.5rem;
			font-size: 0.9rem;
		}

		.warning-box p {
			margin-bottom: 0.25rem;
		}

		/* Presets */
		.presets-grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 0.75rem;
		}

		.preset-btn {
			background: var(--surface);
			border: 1px solid var(--border);
			padding: 0.75rem;
			border-radius: 0.5rem;
			color: var(--text);
			font-weight: 500;
			font-size: 0.875rem;
			cursor: pointer;
			transition: all 0.2s;
		}

		.preset-btn:hover {
			border-color: var(--primary);
			color: var(--primary);
			transform: translateY(-1px);
		}

		/* Reference */
		.reference-section {
			margin-top: 3rem;
			padding-top: 2rem;
			border-top: 1px solid var(--border);
			color: var(--text-muted);
			font-size: 0.875rem;
		}

		.reference-section h3 {
			color: var(--text);
			margin-bottom: 1rem;
		}

		.reference-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 2rem;
		}

		.hidden {
			display: none !important;
		}

		/* Mobile Optimizations */
		@media (max-width: 1024px) {
			.main-grid {
				grid-template-columns: 1fr;
				gap: 1rem;
			}
			.result-card {
				position: static;
			}
		}

		@media (max-width: 600px) {
			body {
				padding: 0;
				background: var(--surface);
			}

			.container {
				padding: 1rem;
			}

			.app-header {
				flex-direction: column;
				align-items: flex-start;
				margin-bottom: 1.5rem;
			}

			.selectors {
				width: 100%;
			}

			.selectors select {
				flex: 1;
			}

			.main-grid {
				display: flex;
				flex-direction: column;
			}

			.card {
				border: none;
				padding: 0;
				margin-bottom: 2rem;
				border-bottom: 1px solid var(--border);
				border-radius: 0;
				padding-bottom: 1.5rem;
			}

			.card:last-child {
				border-bottom: none;
			}

			.result-card {
				border: 1px solid var(--border);
				background: var(--input-bg);
				margin-bottom: 2rem;
			}

			.result-value {
				font-size: 3rem;
			}

			input[type="range"] {
				height: 8px; /* Larger touch target */
			}

			input[type="range"]::-webkit-slider-thumb {
				width: 24px;
				height: 24px;
			}

			.reference-grid {
				grid-template-columns: 1fr;
				gap: 1rem;
			}
		}
	</style>
</head>
<body>
	<div class="container">
		<header class="app-header">
			<div class="title-group">
				<h1 id="title">LLM VRAM Calculator</h1>
				<p id="subtitle" class="subtitle">Calculate maximum model size based on your hardware.</p>
			</div>
			<div class="selectors">
				<select id="language">
					<option value="en">English</option>
					<option value="id">Bahasa Indonesia</option>
				</select>
				<select id="theme">
					<option value="auto">Auto</option>
					<option value="light">Light</option>
					<option value="dark">Dark</option>
				</select>
			</div>
		</header>
		
		<div class="main-grid">
			<!-- Controls Column -->
			<div class="controls-column">
				<div class="card">
					<h2 id="vramLabel">GPU Memory</h2>
					<div class="form-group">
						<div class="label-row">
							<label id="vramSizeLabel">VRAM Size</label>
							<span class="value" id="vramValue">24 GB</span>
						</div>
						<input type="range" id="vramSlider" min="4" max="256" step="4" value="24">
						<div class="slider-labels">
							<span>4GB</span>
							<span>64GB</span>
							<span>128GB</span>
							<span>256GB</span>
						</div>
					</div>
					
					<div class="form-group">
						<div class="label-row">
							<label id="gpuTypeLabel">GPU Type</label>
						</div>
						<select id="gpuType" class="full-width">
							<option value="discrete">Discrete GPU (NVIDIA/AMD)</option>
							<option value="soc">Apple Silicon (M-series)</option>
							<option value="snapdragon">Snapdragon (Windows on Arm)</option>
						</select>
					</div>

					<div class="form-group">
						<div class="label-row">
							<label id="overheadLabel">System Overhead</label>
							<span class="value" id="overheadValueDisplay">1.5 GB</span>
						</div>
						<input type="range" id="overheadSlider" min="0" max="16" step="0.1" value="1.5">
						<div class="slider-labels">
							<span>0GB</span>
							<span>8GB</span>
							<span>16GB</span>
						</div>
					</div>
				</div>
				
				<div class="card">
					<h2 id="quantizationLabel">Quantization</h2>
					<div class="form-group">
						<div class="label-row">
							<label id="modelQuantLabel">Model Precision</label>
						</div>
						<select id="quantization" class="full-width">
							<option value="fp32">FP32 (4.0 bytes)</option>
							<option value="fp16" selected>FP16 (2.0 bytes)</option>
							<option value="bf16">BF16 (2.0 bytes)</option>
							<option value="fp8">FP8 (1.0 byte)</option>
							<option value="int8">INT8 (1.0 byte)</option>
							<option value="int4">INT4 (0.5 bytes)</option>
							<option value="fp4">FP4 (0.5 bytes)</option>
							<option value="fp2">FP2 (0.25 bytes)</option>
						</select>
					</div>

					<div class="form-group">
						<div class="label-row">
							<label id="kvCacheLabel">KV Cache</label>
						</div>
						<select id="kvCache" class="full-width">
							<option value="same" selected>Same as Model</option>
							<option value="fp16">FP16 (2.0 bytes)</option>
							<option value="fp8">FP8 (1.0 byte)</option>
							<option value="int8">INT8 (1.0 byte)</option>
							<option value="int4">INT4 (0.5 bytes)</option>
						</select>
					</div>
				</div>
				
				<div class="card">
					<h2 id="contextLabel">Context Window</h2>
					<div class="form-group">
						<div class="label-row">
							<label id="maxContextLabel">Max Context</label>
							<span class="value" id="contextValue">8,192 tokens</span>
						</div>
						<input type="range" id="contextSlider" min="9" max="20" step="1" value="13">
						<div class="slider-labels">
							<span>512</span>
							<span>8K</span>
							<span>128K</span>
							<span>1M</span>
						</div>
					</div>
				</div>
			</div>
			
			<!-- Results Column -->
			<div class="results-column">
				<div class="result-card">
					<h3 class="result-category" id="maxParamsLabel">Maximum Parameters</h3>
					<div class="result-value" id="resultValue">0B</div>
					<div class="result-category" id="resultCategory"></div>

					<div class="model-details hidden" id="modelDetails">
						<div class="detail-item">
							<span id="layersLabel">Layers</span>
							<span id="layersValue">-</span>
						</div>
						<div class="detail-item">
							<span id="hiddenLabel">Hidden Size</span>
							<span id="hiddenValue">-</span>
						</div>
					</div>
				</div>
				
				<div id="warningBox" class="warning-box hidden"></div>

				<div class="card">
					<h2 id="memoryAllocationLabel">Memory Allocation</h2>
					<div id="metricsList"></div>
				</div>
				
				<div class="card">
					<h2 id="presetsLabel">Quick Presets</h2>
					<div class="presets-grid">
						<button class="preset-btn" data-preset="rtx5050">RTX 5050</button>
						<button class="preset-btn" data-preset="rtx4090">RTX 4090</button>
						<button class="preset-btn" data-preset="a100">A100 80GB</button>
						<button class="preset-btn" data-preset="h200">H200</button>
						<button class="preset-btn" data-preset="m4max">M4 Max</button>
						<button class="preset-btn" data-preset="snapdragon">Snapdragon</button>
					</div>
				</div>
			</div>
		</div>
		
		<div class="reference-section">
			<h3 id="referenceTitle">References & Methodology</h3>
			<div class="reference-grid">
				<div id="formulasSection"></div>
				<div id="architectureSection"></div>
			</div>
			<div style="margin-top: 1rem; opacity: 0.8;" id="sourcesText"></div>
		</div>
	</div>
	
	<script>
		const text = {
			en: {
				title: 'LLM VRAM Calculator',
				subtitle: 'Calculate maximum model size that fits in your GPU memory, accounting for quantization, KV cache, and system overhead',
				autoTheme: 'Auto',
				lightTheme: 'Light',
				darkTheme: 'Dark',
				vramLabel: 'GPU Memory',
				vramSizeLabel: 'VRAM Size',
				systemRamLabel: 'Total System RAM',
				gpuTypeLabel: 'GPU Type',
				overheadLabel: 'System Overhead Deduction',
				quantizationLabel: 'Quantization',
				modelQuantLabel: 'Model Precision',
				kvCacheLabel: 'KV Cache',
				contextLabel: 'Context Window',
				maxContextLabel: 'Max Context',
				maxParamsLabel: 'Maximum Parameters',
				memoryAllocationLabel: 'Memory Allocation',
				presetsLabel: 'Quick Presets',
				referenceTitle: 'References & Methodology',
				
				totalVram: 'Total VRAM',
				systemOverhead: 'System Overhead',
				kvCacheMemory: 'KV Cache',
				modelWeights: 'Model Weights',
				
				layersLabel: 'Layers',
				hiddenLabel: 'Hidden Size',
				
				categorySuffix: '•',
				categoryToy: 'Toy',
				categorySmall: 'Small',
				categoryMedium: 'Medium',
				categoryLarge: 'Large',
				categoryVeryLarge: 'Very Large',
				categoryMassive: 'Massive',
				estimatedArchitecture: 'Estimated Architecture',
				reserved: 'Reserved',
				mbPerToken: 'MB/token',
				
				warningKvCache: '⚠️ KV cache >50% of VRAM. Reduce context.',
				warningInsufficient: '❌ Insufficient VRAM for model.',
				insufficient: 'INSUFFICIENT',
				
				formulas: '<strong>Formulas:</strong><br>• Model: params × bytes/param<br>• KV Cache: 2 × layers × hidden × context × bytes<br>• Overhead: Fixed amount (OS, Display, Framework)',
				architecture: '<strong>Reference Data:</strong><br>• Llama 3/3.1: 8B=32L×4096d, 70B=80L×8192d<br>• Mistral 7B: 32L×4096d, GQA(32q/8kv heads)<br>• Gemma 2: 9B=42L×3584d, 27B=46L×4608d<br>• Qwen 2.5: 7B=28L×3584d, 72B=80L×8192d',
				sources: '<strong>Sources:</strong> Meta Llama Technical Reports (2024-2025), Mistral AI Docs & Papers (2023-2024), Google Gemma Blog & HF Docs (2024), Qwen 2.5 Technical Report (2024), HuggingFace Model Cards, NVIDIA Technical Blogs, vLLM Documentation'
			},
			id: {
				title: 'Kalkulator VRAM LLM',
				subtitle: 'Hitung ukuran model maksimum yang muat dalam memori GPU Anda, dengan memperhitungkan kuantisasi, KV cache, dan overhead sistem',
				autoTheme: 'Otomatis',
				lightTheme: 'Terang',
				darkTheme: 'Gelap',
				vramLabel: 'Memori GPU',
				vramSizeLabel: 'Ukuran VRAM',
				systemRamLabel: 'Total RAM Sistem',
				gpuTypeLabel: 'Tipe GPU',
				overheadLabel: 'Deduksi Overhead Sistem',
				quantizationLabel: 'Kuantisasi',
				modelQuantLabel: 'Presisi Model',
				kvCacheLabel: 'KV Cache',
				contextLabel: 'Jendela Konteks',
				maxContextLabel: 'Konteks Maks',
				maxParamsLabel: 'Parameter Maksimum',
				memoryAllocationLabel: 'Alokasi Memori',
				presetsLabel: 'Preset Cepat',
				referenceTitle: 'Referensi & Metodologi',
				
				totalVram: 'Total VRAM',
				systemOverhead: 'Overhead Sistem',
				kvCacheMemory: 'KV Cache',
				modelWeights: 'Bobot Model',
				
				layersLabel: 'Lapisan',
				hiddenLabel: 'Ukuran Tersembunyi',
				
				categorySuffix: '•',
				categoryToy: 'Mainan',
				categorySmall: 'Kecil',
				categoryMedium: 'Sedang',
				categoryLarge: 'Besar',
				categoryVeryLarge: 'Sangat Besar',
				categoryMassive: 'Masif',
				estimatedArchitecture: 'Arsitektur Terestimasi',
				reserved: 'Dicadangkan',
				mbPerToken: 'MB/token',
				
				warningKvCache: '⚠️ KV cache >50% dari VRAM. Kurangi konteks.',
				warningInsufficient: '❌ VRAM tidak cukup untuk model.',
				insufficient: 'TIDAK CUKUP',
				
				formulas: '<strong>Formula:</strong><br>• Model: params × byte/param<br>• KV Cache: 2 × lapisan × tersembunyi × konteks × byte<br>• Overhead: Jumlah tetap (OS, Tampilan, Framework)',
				architecture: '<strong>Data Referensi:</strong><br>• Llama 3/3.1: 8B=32L×4096d, 70B=80L×8192d<br>• Mistral 7B: 32L×4096d, GQA(32q/8kv head)<br>• Gemma 2: 9B=42L×3584d, 27B=46L×4608d<br>• Qwen 2.5: 7B=28L×3584d, 72B=80L×8192d',
				sources: '<strong>Sumber:</strong> Laporan Teknis Meta Llama (2024-2025), Dokumen & Makalah Mistral AI (2023-2024), Blog Google Gemma & Dokumen HF (2024), Laporan Teknis Qwen 2.5 (2024), Kartu Model HuggingFace, Blog Teknis NVIDIA, Dokumentasi vLLM'
			}
		};
		
		const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });
		
		const referenceConfigs = [
			{ size: 0.5, layers: 24, hidden: 896 },
			{ size: 1.5, layers: 28, hidden: 1536 },
			{ size: 3.0, layers: 28, hidden: 3072 },
			{ size: 7.0, layers: 32, hidden: 4096 },
			{ size: 14.0, layers: 48, hidden: 5120 },
			{ size: 32.0, layers: 64, hidden: 5120 },
			{ size: 70.0, layers: 80, hidden: 8192 },
			{ size: 405.0, layers: 126, hidden: 16384 }
		];

		function estimateArchitecture(params) {
			referenceConfigs.sort((a, b) => a.size - b.size);

			if (params <= referenceConfigs[0].size) {
				return {
					layers: referenceConfigs[0].layers,
					hidden: referenceConfigs[0].hidden
				};
			}

			if (params >= referenceConfigs[referenceConfigs.length - 1].size) {
				return {
					layers: referenceConfigs[referenceConfigs.length - 1].layers,
					hidden: referenceConfigs[referenceConfigs.length - 1].hidden
				};
			}

			for (let i = 0; i < referenceConfigs.length - 1; i++) {
				const lower = referenceConfigs[i];
				const upper = referenceConfigs[i+1];

				if (params >= lower.size && params <= upper.size) {
					const ratio = (params - lower.size) / (upper.size - lower.size);
					return {
						layers: Math.round(lower.layers + (upper.layers - lower.layers) * ratio),
						hidden: Math.round(lower.hidden + (upper.hidden - lower.hidden) * ratio)
					};
				}
			}

			return referenceConfigs[0];
		}
		
		const quantizationBits = {
			'fp32': 32, 'fp16': 16, 'bf16': 16, 'fp8': 8,
			'int8': 8, 'int4': 4, 'fp4': 4, 'fp2': 2
		};
		
		class LLMCalculator {
			constructor() {
				this.vramSize = 24;
				this.quantization = 'fp16';
				this.contextWindow = 8192;
				this.kvCacheQuant = 'same';
				this.gpuType = 'discrete';
				this.manualOverhead = 1.5;
				
				this.setup();
				this.theme('auto');
				this.language = navigator.language?.startsWith('id') ? 'id' : 'en';
				this.lang(this.language);
			}
			
			setup() {
				elements.language.onchange = e => this.lang(e.target.value);
				elements.theme.onchange = e => this.theme(e.target.value);
				
				elements.vramSlider.oninput = e => {
					this.vramSize = Number(e.target.value);
					this.updateVramDisplay();
					this.calculate();
				};

				elements.quantization.onchange = e => {
					this.quantization = e.target.value;
					this.calculate();
				};
				
				elements.kvCache.onchange = e => {
					this.kvCacheQuant = e.target.value;
					this.calculate();
				};
				
				elements.contextSlider.oninput = e => {
					this.contextWindow = Math.pow(2, Number(e.target.value));
					this.updateContextDisplay();
					this.calculate();
				};
				
				elements.gpuType.onchange = e => {
					this.gpuType = e.target.value;
					this.updateVramDisplay();
					this.calculate();
				};

				elements.overheadSlider.oninput = e => {
					this.manualOverhead = Number(e.target.value);
					this.calculate();
				};
				
				document.querySelectorAll('.preset-btn').forEach(btn => {
					btn.onclick = () => this.applyPreset(btn.dataset.preset);
				});
			}
			
			applyPreset(preset) {
				const presets = {
					rtx5050: { vram: 8, quant: 'int4', context: 8192, gpu: 'discrete', overhead: 1.5 },
					rtx4090: { vram: 24, quant: 'int4', context: 8192, gpu: 'discrete', overhead: 1.5 },
					a100: { vram: 80, quant: 'fp16', context: 32768, gpu: 'discrete', overhead: 0.5 },
					h200: { vram: 192, quant: 'fp16', context: 131072, gpu: 'discrete', overhead: 0.5 },
					m4max: { vram: 128, quant: 'int4', context: 32768, gpu: 'soc' },
					snapdragon: { vram: 32, quant: 'int4', context: 8192, gpu: 'snapdragon' }
				};
				
				const p = presets[preset];
				if (p) {
					this.vramSize = p.vram;
					this.quantization = p.quant;
					this.contextWindow = p.context;
					this.gpuType = p.gpu;
					if (p.overhead !== undefined) this.manualOverhead = p.overhead;
					
					elements.vramSlider.value = p.vram;
					elements.quantization.value = p.quant;
					elements.contextSlider.value = Math.log2(p.context);
					elements.gpuType.value = p.gpu;
					elements.overheadSlider.value = this.manualOverhead;
					
					this.updateVramDisplay();
					this.updateContextDisplay();
					this.calculate();
				}
			}
			
			updateVramDisplay() {
				elements.vramValue.textContent = `${this.vramSize} GB`;

				// Update label based on GPU type
				const isSoc = this.gpuType === 'soc' || this.gpuType === 'snapdragon';
				elements.vramSizeLabel.textContent = isSoc ?
					this.string('systemRamLabel') : this.string('vramSizeLabel');
			}
			
			updateContextDisplay() {
				elements.contextValue.textContent = `${this.format(this.contextWindow)} tokens`;
			}
			
			calculate() {
				const bytesPerParam = quantizationBits[this.quantization] / 8;
				const kvQuantBits = this.kvCacheQuant === 'same' ? 
					quantizationBits[this.quantization] : quantizationBits[this.kvCacheQuant];
				const t = text[this.language];
				const bytesPerKvElement = kvQuantBits / 8;
				
				let overheadGB = 0;
				let availableVram = 0;
				let overheadMsg = "";

				if (this.gpuType === 'discrete') {
					overheadGB = this.manualOverhead;
					availableVram = this.vramSize - overheadGB;
					elements.overheadSlider.disabled = false;
					elements.overheadSlider.value = this.manualOverhead;
				} else {
					elements.overheadSlider.disabled = true;
					if (this.gpuType === 'soc') {
						// Apple Silicon: ~75% available for GPU
						availableVram = this.vramSize * 0.75;
						overheadGB = this.vramSize - availableVram;
						overheadMsg = `${t.reserved} (25%)`;
					} else if (this.gpuType === 'snapdragon') {
						// Snapdragon/Windows SoC: ~50% available for GPU
						availableVram = this.vramSize * 0.50;
						overheadGB = this.vramSize - availableVram;
						overheadMsg = `${t.reserved} (50%)`;
					}
					// Update slider display for read-only view
					elements.overheadSlider.value = overheadGB;
				}

				elements.overheadValueDisplay.textContent = `${overheadGB.toFixed(1)} GB`;

				const availableForUse = Math.max(0, availableVram);
				
				let maxParams = 0;
				let estimatedArchitecture = { layers: 0, hidden: 0 };
				
				for (let i = 0; i < 5; i++) {
					const kvCache = estimatedArchitecture.layers ?
						(2 * estimatedArchitecture.layers * estimatedArchitecture.hidden * this.contextWindow * bytesPerKvElement) / (1024 ** 3) : 0;
					
					const memoryForWeights = availableForUse - kvCache;
					
					if (memoryForWeights <= 0) {
						maxParams = 0;
						break;
					}
					
					maxParams = memoryForWeights / bytesPerParam;
					estimatedArchitecture = estimateArchitecture(maxParams);
				}
				
				const kvCacheGB = estimatedArchitecture.layers ?
					(2 * estimatedArchitecture.layers * estimatedArchitecture.hidden * this.contextWindow * bytesPerKvElement) / (1024 ** 3) : 0;
				
				const results = {
					totalVram: this.vramSize,
					overheadGB: overheadGB,
					overheadMsg: overheadMsg,
					availableVram: availableForUse,
					kvCacheGB: kvCacheGB,
					modelMemoryGB: Math.max(0, availableForUse - kvCacheGB),
					maxParams: maxParams,
					estimatedArchitecture: estimatedArchitecture
				};
				
				this.displayResults(results);
			}
			
			displayResults(results) {
				const t = text[this.language];
				
				if (results.modelMemoryGB > 0) {
					elements.resultValue.textContent = `${Math.floor(results.maxParams)}B`;
					elements.resultValue.className = 'result-value';
					
					const category = this.getModelCategory(results.maxParams);
					elements.resultCategory.textContent = `${category} ${t.categorySuffix} ${t.estimatedArchitecture}`;
					
					if (results.estimatedArchitecture) {
						elements.modelDetails.classList.remove('hidden');
						elements.layersValue.textContent = results.estimatedArchitecture.layers;
						elements.hiddenValue.textContent = results.estimatedArchitecture.hidden;
					} else {
						elements.modelDetails.classList.add('hidden');
					}
				} else {
					elements.resultValue.textContent = t.insufficient;
					elements.resultValue.className = 'result-value insufficient';
					elements.resultCategory.textContent = '';
					elements.modelDetails.classList.add('hidden');
				}
				
				const mbPerToken = (results.kvCacheGB * 1024 / this.contextWindow).toFixed(2);
				elements.metricsList.innerHTML = `
					<div class="metric-row">
						<span class="metric-label">${t.totalVram}</span>
						<div class="metric-value-group">
							<div class="metric-val">${results.totalVram} GB</div>
						</div>
					</div>
					<div class="metric-row">
						<span class="metric-label">${t.systemOverhead}</span>
						<div class="metric-value-group">
							<div class="metric-val" style="color: var(--danger)">-${results.overheadGB.toFixed(1)} GB</div>
							${results.overheadMsg ? `<span class="metric-sub">${results.overheadMsg}</span>` : ''}
						</div>
					</div>
					<div class="metric-row">
						<span class="metric-label">${t.kvCacheMemory}</span>
						<div class="metric-value-group">
							<div class="metric-val" style="color: var(--warning)">-${results.kvCacheGB.toFixed(2)} GB</div>
							<span class="metric-sub">${mbPerToken} ${t.mbPerToken}</span>
						</div>
					</div>
					<div class="metric-row" style="border-top: 1px dashed var(--border); margin-top: 0.5rem; padding-top: 0.5rem;">
						<span class="metric-label" style="font-weight: 700; color: var(--text)">${t.modelWeights}</span>
						<div class="metric-value-group">
							<div class="metric-val" style="color: var(--primary);">${Math.max(0, results.modelMemoryGB).toFixed(2)} GB</div>
						</div>
					</div>
				`;
				
				const warnings = [];
				if (results.kvCacheGB > results.availableVram * 0.5) {
					warnings.push(t.warningKvCache);
				}
				if (results.modelMemoryGB <= 0) {
					warnings.push(t.warningInsufficient);
				}
				
				if (warnings.length > 0) {
					elements.warningBox.innerHTML = warnings.map(w => `<p>${w}</p>`).join('');
					elements.warningBox.classList.remove('hidden');
				} else {
					elements.warningBox.classList.add('hidden');
				}
			}
			
			getModelCategory(params) {
				const t = text[this.language];
				if (params < 1) return t.categoryToy;
				if (params < 3) return t.categorySmall;
				if (params < 10) return t.categoryMedium;
				if (params < 20) return t.categoryLarge;
				if (params < 40) return t.categoryVeryLarge;
				return t.categoryMassive;
			}
			
			format(value, options = {}) {
				return value.toLocaleString(this.language === 'id' ? 'id-ID' : 'en-US', options);
			}
			
			string(key) {
				return text[this.language]?.[key] ?? key;
			}
			
			theme(themeName) {
				document.documentElement.className = themeName === 'auto' ? '' : themeName;
				elements.theme.value = themeName;
			}
			
			lang(language) {
				this.language = elements.language.value = document.documentElement.lang = language;
				
				Object.keys(text.en).forEach(key => {
					if (elements[key]) {
						elements[key].textContent = this.string(key);
					}
				});
				
				[...elements.theme.options].forEach(option => {
					option.textContent = this.string(option.value + 'Theme');
				});
				
				elements.formulasSection.innerHTML = this.string('formulas');
				elements.architectureSection.innerHTML = this.string('architecture');
				elements.sourcesText.innerHTML = this.string('sources');
				
				this.updateVramDisplay();
				this.updateContextDisplay();
				this.calculate();
			}
		}
		
		new LLMCalculator();
	</script>
</body>
</html>
