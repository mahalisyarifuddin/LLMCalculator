<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>LLM VRAM Calculator</title>
	<style>
		:root {
			--primary: #005dac;
			--on-primary: #ffffff;
			--hover: #00539a;
			--background: #f9f9ff;
			--surface: #ffffff;
			--text: #181c21;
			--border: #c1c6d4;
			--muted: #f2f3fc;
			--success: #0b6b1d;
			--on-success: #ffffff;
			--danger: #ba1a1a;
			--on-danger: #ffffff;
			--warning: #e65100;
			--on-warning: #ffffff;
			--highlight-bg: #d4e3ff;
		}
		@media (prefers-color-scheme: dark) {
			:root:not(.light) {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--warning: #ffb77c;
				--on-warning: #4d2600;
				--highlight-bg: #001c3a;
			}
		}
		:root.dark {
			--primary: #a5c8ff;
			--on-primary: #00315f;
			--hover: #72adff;
			--background: #101319;
			--surface: #0b0e14;
			--text: #e0e2ea;
			--border: #414752;
			--muted: #181c21;
			--success: #82db7e;
			--on-success: #00390a;
			--danger: #ffb4ab;
			--on-danger: #93000a;
			--warning: #ffb77c;
			--on-warning: #4d2600;
			--highlight-bg: #001c3a;
		}
		* { 
			box-sizing: border-box; 
			margin: 0; 
			padding: 0; 
			outline-offset: 2px; 
		}
		*:focus-visible { 
			outline: 2px solid var(--primary); 
		}
		body {
			background: var(--background);
			color: var(--text);
			font-family: sans-serif;
			display: flex;
			justify-content: center;
			min-height: 100vh;
			padding: 1rem;
		}
		.container {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 8px;
			max-width: 1400px;
			padding: 2rem;
			width: 100%;
			position: relative;
			margin: 2rem 0;
		}
		.hidden { 
			display: none !important; 
		}
		h1, h2, h3, label { 
			margin: .5rem 0; 
		}
		h1 {
			font-size: 2rem;
			text-align: center;
			color: var(--primary);
			margin-bottom: 0.5rem;
		}
		h2 {
			font-size: 1.1rem;
			font-weight: 700;
			color: var(--primary);
		}
		label { 
			display: block; 
			font-weight: 700;
			font-size: 0.9rem;
		}
		input, select, button, textarea {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 4px;
			color: var(--text);
			font-size: 1rem;
			padding: .5rem;
			width: 100%;
		}
		textarea {
			resize: vertical;
			min-height: 80px;
		}
		button { 
			cursor: pointer; 
		}
		button:disabled { 
			opacity: .6; 
			cursor: not-allowed; 
		}
		.primary { 
			background: var(--primary); 
			color: var(--on-primary); 
			border: 0; 
		}
		.primary:hover:not(:disabled) { 
			background: var(--hover); 
		}
		.secondary:hover:not(:disabled) { 
			background: var(--muted); 
		}
		.danger { 
			background: var(--danger); 
			color: var(--on-danger); 
			border: 0; 
		}
		.success { 
			background: var(--success); 
			color: var(--on-success); 
			border: 0; 
		}
		.selectors {
			position: absolute;
			right: 2rem;
			top: 1rem;
			display: flex;
			gap: 8px;
		}
		.selectors select { 
			width: auto; 
			font-size: .9rem; 
		}
		.subtitle {
			text-align: center;
			font-size: 0.9rem;
			opacity: 0.8;
			line-height: 1.6;
			margin-bottom: 2rem;
		}
		.main-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 2rem;
			margin-bottom: 2rem;
		}
		.card {
			background: var(--muted);
			border: 1px solid var(--border);
			border-radius: 8px;
			padding: 1.5rem;
			margin-bottom: 1rem;
		}
		.card:last-child {
			margin-bottom: 0;
		}
		.form-group { 
			margin-bottom: 1.5rem; 
		}
		.form-group:last-child {
			margin-bottom: 0;
		}
		.form-group label .value {
			color: var(--primary);
			font-weight: 700;
		}
		input[type="range"] {
			-webkit-appearance: none;
			appearance: none;
			width: 100%;
			height: 8px;
			background: var(--border);
			border-radius: 4px;
			outline: none;
			cursor: pointer;
			border: 0;
		}
		input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 20px;
			height: 20px;
			border-radius: 50%;
			background: var(--primary);
			cursor: pointer;
		}
		input[type="range"]::-moz-range-thumb {
			width: 20px;
			height: 20px;
			border-radius: 50%;
			background: var(--primary);
			border: 0;
			cursor: pointer;
		}
		.slider-labels {
			display: flex;
			justify-content: space-between;
			font-size: 0.75rem;
			opacity: 0.7;
			margin-top: 0.5rem;
		}
		.result-box {
			text-align: center;
			padding: 2rem 1rem;
		}
		.result-value {
			font-size: 3rem;
			font-weight: 700;
			color: var(--primary);
			margin: 1rem 0;
		}
		.result-category {
			font-size: 0.85rem;
			opacity: 0.8;
			margin-bottom: 1rem;
		}
		.model-details {
			padding-top: 1rem;
			border-top: 1px solid var(--border);
			margin-top: 1rem;
		}
		.detail-row {
			display: flex;
			justify-content: space-between;
			font-size: 0.85rem;
			margin-bottom: 0.5rem;
		}
		.detail-row .label {
			opacity: 0.8;
		}
		.detail-row .value {
			color: var(--primary);
			font-weight: 700;
		}
		.metric-card {
			background: var(--surface);
			border: 1px solid var(--border);
			border-left: 3px solid var(--primary);
			padding: 0.75rem;
			border-radius: 4px;
			margin-bottom: 0.75rem;
		}
		.metric-card:last-child {
			margin-bottom: 0;
		}
		.metric-card .metric-label {
			font-size: 0.85rem;
			opacity: 0.8;
			margin-bottom: 0.25rem;
		}
		.metric-card .metric-value {
			font-size: 1.1rem;
			font-weight: 700;
		}
		.metric-card .metric-detail {
			font-size: 0.75rem;
			opacity: 0.7;
			margin-top: 0.25rem;
		}
		.warning-box {
			background: var(--warning);
			color: var(--on-warning);
			border-radius: 4px;
			padding: 1rem;
			margin-bottom: 1rem;
		}
		.warning-box p {
			font-size: 0.85rem;
			margin-bottom: 0.5rem;
		}
		.warning-box p:last-child {
			margin-bottom: 0;
		}
		.presets {
			display: grid;
			grid-template-columns: repeat(2, 1fr);
			gap: 0.5rem;
		}
		.preset-btn {
			padding: 0.75rem;
			background: var(--surface);
			border: 1px solid var(--border);
			color: var(--text);
			font-size: 0.85rem;
			border-radius: 4px;
			cursor: pointer;
		}
		.preset-btn:hover {
			background: var(--highlight-bg);
			border-color: var(--primary);
		}
		.reference-section {
			background: var(--muted);
			border: 1px solid var(--border);
			border-radius: 8px;
			padding: 1.5rem;
		}
		.reference-section h3 {
			font-size: 1rem;
			font-weight: 700;
			color: var(--primary);
			margin-bottom: 1rem;
		}
		.reference-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 1.5rem;
			font-size: 0.85rem;
			opacity: 0.9;
			line-height: 1.6;
		}
		.reference-grid p {
			margin-bottom: 0.5rem;
		}
		.reference-grid strong {
			color: var(--primary);
		}
		.insufficient {
			color: var(--danger);
		}
		.grid-row {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 1rem;
		}
		@media (max-width: 1024px) {
			.main-grid {
				grid-template-columns: 1fr;
			}
			.reference-grid {
				grid-template-columns: 1fr;
			}
		}
		@media (max-width: 768px) {
			.selectors { 
				position: static; 
				justify-content: end; 
				margin-bottom: 1rem; 
			}
			.grid-row {
				grid-template-columns: 1fr;
			}
			h1 {
				font-size: 1.5rem;
			}
			.result-value {
				font-size: 2rem;
			}
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="selectors">
			<select id="language">
				<option value="en">English</option>
				<option value="id">Bahasa Indonesia</option>
			</select>
			<select id="theme">
				<option value="auto">Auto</option>
				<option value="light">Light</option>
				<option value="dark">Dark</option>
			</select>
		</div>
		<h1 id="title"></h1>
		<p id="subtitle" class="subtitle"></p>
		
		<div class="main-grid">
			<div>
				<div class="card">
					<h2 id="vramLabel"></h2>
					<div class="form-group">
						<label>
							<span id="vramSizeLabel"></span> 
							<span class="value" id="vramValue">24 GB</span>
						</label>
						<input type="range" id="vramSlider" min="4" max="256" step="4" value="24">
						<div class="slider-labels">
							<span>4GB</span>
							<span>64GB</span>
							<span>128GB</span>
							<span>256GB</span>
						</div>
					</div>
					
					<div class="form-group">
						<label id="gpuTypeLabel"></label>
						<select id="gpuType">
							<option value="discrete">Discrete GPU (NVIDIA/AMD)</option>
							<option value="soc">Apple Silicon (M-series)</option>
							<option value="snapdragon">Snapdragon (Windows on Arm)</option>
						</select>
					</div>

				</div>
				
				<div class="card">
					<h2 id="quantizationLabel"></h2>
					<div class="grid-row">
						<div class="form-group">
							<label id="modelQuantLabel"></label>
							<select id="quantization">
								<option value="fp32">FP32 (4.0 bytes)</option>
								<option value="fp16" selected>FP16 (2.0 bytes)</option>
								<option value="bf16">BF16 (2.0 bytes)</option>
								<option value="fp8">FP8 (1.0 byte)</option>
								<option value="int8">INT8 (1.0 byte)</option>
								<option value="int4">INT4 (0.5 bytes)</option>
								<option value="fp4">FP4 (0.5 bytes)</option>
								<option value="fp2">FP2 (0.25 bytes)</option>
							</select>
						</div>
						
						<div class="form-group">
							<label id="kvCacheLabel"></label>
							<select id="kvCache">
								<option value="same" selected>Same as Model</option>
								<option value="fp16">FP16 (2.0 bytes)</option>
								<option value="fp8">FP8 (1.0 byte)</option>
								<option value="int8">INT8 (1.0 byte)</option>
								<option value="int4">INT4 (0.5 bytes)</option>
							</select>
						</div>
					</div>
				</div>
				
				<div class="card">
					<h2 id="contextLabel"></h2>
					<div class="form-group">
						<label>
							<span id="maxContextLabel"></span> 
							<span class="value" id="contextValue">8,192 tokens</span>
						</label>
						<input type="range" id="contextSlider" min="9" max="20" step="1" value="13">
						<div class="slider-labels">
							<span>512</span>
							<span>2K</span>
							<span>8K</span>
							<span>32K</span>
							<span>128K</span>
							<span>512K</span>
							<span>1M</span>
						</div>
					</div>
				</div>
			</div>
			
			<div>
				<div class="card">
					<div class="result-box">
						<h2 id="maxParamsLabel"></h2>
						<div class="result-value" id="resultValue">0B</div>
						<div class="result-category" id="resultCategory"></div>
						
						<div class="model-details hidden" id="modelDetails">
							<div class="detail-row">
								<span class="label" id="layersLabel"></span>
								<span class="value" id="layersValue">-</span>
							</div>
							<div class="detail-row">
								<span class="label" id="hiddenLabel"></span>
								<span class="value" id="hiddenValue">-</span>
							</div>
						</div>
					</div>
				</div>
				
				<div class="card">
					<h2 id="memoryAllocationLabel"></h2>
					<div id="metricsList"></div>
				</div>
				
				<div id="warningBox" class="warning-box hidden"></div>
				
				<div class="card">
					<h2 id="presetsLabel"></h2>
					<div class="presets">
						<button class="preset-btn" data-preset="rtx5050">RTX 5050</button>
						<button class="preset-btn" data-preset="rtx4090">RTX 4090</button>
						<button class="preset-btn" data-preset="a100">A100 80GB</button>
						<button class="preset-btn" data-preset="h200">H200</button>
						<button class="preset-btn" data-preset="m4max">M4 Max</button>
						<button class="preset-btn" data-preset="snapdragon">Snapdragon</button>
					</div>
				</div>
			</div>
		</div>
		
		<div class="reference-section">
			<h3 id="referenceTitle"></h3>
			<div class="reference-grid">
				<div id="formulasSection"></div>
				<div id="architectureSection"></div>
			</div>
			<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
				<p style="font-size: 0.85rem; opacity: 0.8;" id="sourcesText"></p>
			</div>
		</div>
	</div>
	
	<script>
		const text = {
			en: {
				title: 'LLM VRAM Calculator',
				subtitle: 'Calculate maximum model size that fits in your GPU memory, accounting for quantization, KV cache, and system overhead',
				autoTheme: 'Auto',
				lightTheme: 'Light',
				darkTheme: 'Dark',
				vramLabel: 'GPU Memory',
				vramSizeLabel: 'VRAM Size:',
				systemRamLabel: 'Total System RAM:',
				gpuTypeLabel: 'GPU Type',
				overheadLabel: 'System Overhead:',
				quantizationLabel: 'Quantization',
				modelQuantLabel: 'Model Precision',
				kvCacheLabel: 'KV Cache',
				contextLabel: 'Context Window',
				maxContextLabel: 'Max Context:',
				maxParamsLabel: 'Maximum Parameters',
				memoryAllocationLabel: 'Memory Allocation',
				presetsLabel: 'Quick Presets',
				referenceTitle: 'References & Methodology',
				
				totalVram: 'Total VRAM',
				systemOverhead: 'System Overhead',
				kvCacheMemory: 'KV Cache',
				modelWeights: 'Model Weights',
				
				layersLabel: 'Layers:',
				hiddenLabel: 'Hidden Size:',
				
				categorySuffix: '•',
				categoryToy: 'Toy',
				categorySmall: 'Small',
				categoryMedium: 'Medium',
				categoryLarge: 'Large',
				categoryVeryLarge: 'Very Large',
				categoryMassive: 'Massive',
				
				warningKvCache: '⚠️ KV cache >50% of VRAM. Reduce context.',
				warningInsufficient: '❌ Insufficient VRAM for model.',
				insufficient: 'INSUFFICIENT VRAM',
				
				formulas: '<strong>Formulas:</strong><br>• Model: params × bytes/param<br>• KV Cache: 2 × layers × hidden × context × bytes<br>• Overhead: Fixed amount (OS, Display, Framework)',
				architecture: '<strong>Reference Data:</strong><br>• Llama 3/3.1: 8B=32L×4096d, 70B=80L×8192d<br>• Mistral 7B: 32L×4096d, GQA(32q/8kv heads)<br>• Gemma 2: 9B=42L×3584d, 27B=46L×4608d<br>• Qwen 2.5: 7B=28L×3584d, 72B=80L×8192d',
				sources: '<strong>Sources:</strong> Meta Llama Technical Reports (2024-2025), Mistral AI Docs & Papers (2023-2024), Google Gemma Blog & HF Docs (2024), Qwen 2.5 Technical Report (2024), HuggingFace Model Cards, NVIDIA Technical Blogs, vLLM Documentation'
			},
			id: {
				title: 'Kalkulator VRAM LLM',
				subtitle: 'Hitung ukuran model maksimum yang muat dalam memori GPU Anda, dengan memperhitungkan kuantisasi, KV cache, dan overhead sistem',
				autoTheme: 'Otomatis',
				lightTheme: 'Terang',
				darkTheme: 'Gelap',
				vramLabel: 'Memori GPU',
				vramSizeLabel: 'Ukuran VRAM:',
				systemRamLabel: 'Total RAM Sistem:',
				gpuTypeLabel: 'Tipe GPU',
				overheadLabel: 'Overhead Sistem:',
				quantizationLabel: 'Kuantisasi',
				modelQuantLabel: 'Presisi Model',
				kvCacheLabel: 'KV Cache',
				contextLabel: 'Jendela Konteks',
				maxContextLabel: 'Konteks Maks:',
				maxParamsLabel: 'Parameter Maksimum',
				memoryAllocationLabel: 'Alokasi Memori',
				presetsLabel: 'Preset Cepat',
				referenceTitle: 'Referensi & Metodologi',
				
				totalVram: 'Total VRAM',
				systemOverhead: 'Overhead Sistem',
				kvCacheMemory: 'KV Cache',
				modelWeights: 'Bobot Model',
				
				layersLabel: 'Lapisan:',
				hiddenLabel: 'Ukuran Tersembunyi:',
				
				categorySuffix: '•',
				categoryToy: 'Mainan',
				categorySmall: 'Kecil',
				categoryMedium: 'Sedang',
				categoryLarge: 'Besar',
				categoryVeryLarge: 'Sangat Besar',
				categoryMassive: 'Masif',
				
				warningKvCache: '⚠️ KV cache >50% dari VRAM. Kurangi konteks.',
				warningInsufficient: '❌ VRAM tidak cukup untuk model.',
				insufficient: 'VRAM TIDAK CUKUP',
				
				formulas: '<strong>Formula:</strong><br>• Model: params × byte/param<br>• KV Cache: 2 × lapisan × tersembunyi × konteks × byte<br>• Overhead: Jumlah tetap (OS, Tampilan, Framework)',
				architecture: '<strong>Data Referensi:</strong><br>• Llama 3/3.1: 8B=32L×4096d, 70B=80L×8192d<br>• Mistral 7B: 32L×4096d, GQA(32q/8kv head)<br>• Gemma 2: 9B=42L×3584d, 27B=46L×4608d<br>• Qwen 2.5: 7B=28L×3584d, 72B=80L×8192d',
				sources: '<strong>Sumber:</strong> Laporan Teknis Meta Llama (2024-2025), Dokumen & Makalah Mistral AI (2023-2024), Blog Google Gemma & Dokumen HF (2024), Laporan Teknis Qwen 2.5 (2024), Kartu Model HuggingFace, Blog Teknis NVIDIA, Dokumentasi vLLM'
			}
		};
		
		const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });
		
		const referenceConfigs = [
			{ size: 0.5, layers: 24, hidden: 896 },
			{ size: 1.5, layers: 28, hidden: 1536 },
			{ size: 3.0, layers: 28, hidden: 3072 },
			{ size: 7.0, layers: 32, hidden: 4096 },
			{ size: 14.0, layers: 48, hidden: 5120 },
			{ size: 32.0, layers: 64, hidden: 5120 },
			{ size: 70.0, layers: 80, hidden: 8192 },
			{ size: 405.0, layers: 126, hidden: 16384 }
		];

		function estimateArchitecture(params) {
			referenceConfigs.sort((a, b) => a.size - b.size);

			if (params <= referenceConfigs[0].size) {
				return {
					layers: referenceConfigs[0].layers,
					hidden: referenceConfigs[0].hidden
				};
			}

			if (params >= referenceConfigs[referenceConfigs.length - 1].size) {
				return {
					layers: referenceConfigs[referenceConfigs.length - 1].layers,
					hidden: referenceConfigs[referenceConfigs.length - 1].hidden
				};
			}

			for (let i = 0; i < referenceConfigs.length - 1; i++) {
				const lower = referenceConfigs[i];
				const upper = referenceConfigs[i+1];

				if (params >= lower.size && params <= upper.size) {
					const ratio = (params - lower.size) / (upper.size - lower.size);
					return {
						layers: Math.round(lower.layers + (upper.layers - lower.layers) * ratio),
						hidden: Math.round(lower.hidden + (upper.hidden - lower.hidden) * ratio)
					};
				}
			}

			return referenceConfigs[0];
		}
		
		const quantizationBits = {
			'fp32': 32, 'fp16': 16, 'bf16': 16, 'fp8': 8,
			'int8': 8, 'int4': 4, 'fp4': 4, 'fp2': 2
		};
		
		class LLMCalculator {
			constructor() {
				this.vramSize = 24;
				this.quantization = 'fp16';
				this.contextWindow = 8192;
				this.kvCacheQuant = 'same';
				this.gpuType = 'discrete';
				
				this.setup();
				this.theme('auto');
				this.language = navigator.language?.startsWith('id') ? 'id' : 'en';
				this.lang(this.language);
			}
			
			setup() {
				elements.language.onchange = e => this.lang(e.target.value);
				elements.theme.onchange = e => this.theme(e.target.value);
				
				elements.vramSlider.oninput = e => {
					this.vramSize = Number(e.target.value);
					this.updateVramDisplay();
					this.calculate();
				};

				elements.quantization.onchange = e => {
					this.quantization = e.target.value;
					this.calculate();
				};
				
				elements.kvCache.onchange = e => {
					this.kvCacheQuant = e.target.value;
					this.calculate();
				};
				
				elements.contextSlider.oninput = e => {
					this.contextWindow = Math.pow(2, Number(e.target.value));
					this.updateContextDisplay();
					this.calculate();
				};
				
				elements.gpuType.onchange = e => {
					this.gpuType = e.target.value;
					this.updateVramDisplay();
					this.calculate();
				};
				
				document.querySelectorAll('.preset-btn').forEach(btn => {
					btn.onclick = () => this.applyPreset(btn.dataset.preset);
				});
			}
			
			applyPreset(preset) {
				const presets = {
					rtx5050: { vram: 8, quant: 'int4', context: 8192, gpu: 'discrete' },
					rtx4090: { vram: 24, quant: 'int4', context: 8192, gpu: 'discrete' },
					a100: { vram: 80, quant: 'fp16', context: 32768, gpu: 'discrete' },
					h200: { vram: 192, quant: 'fp16', context: 131072, gpu: 'discrete' },
					m4max: { vram: 128, quant: 'int4', context: 32768, gpu: 'soc' },
					snapdragon: { vram: 32, quant: 'int4', context: 8192, gpu: 'snapdragon' }
				};
				
				const p = presets[preset];
				if (p) {
					this.vramSize = p.vram;
					this.quantization = p.quant;
					this.contextWindow = p.context;
					this.gpuType = p.gpu;
					
					elements.vramSlider.value = p.vram;
					elements.quantization.value = p.quant;
					elements.contextSlider.value = Math.log2(p.context);
					elements.gpuType.value = p.gpu;
					
					this.updateVramDisplay();
					this.updateContextDisplay();
					this.calculate();
				}
			}
			
			updateVramDisplay() {
				elements.vramValue.textContent = `${this.vramSize} GB`;

				// Update label based on GPU type
				const isSoc = this.gpuType === 'soc' || this.gpuType === 'snapdragon';
				elements.vramSizeLabel.textContent = isSoc ?
					this.string('systemRamLabel') : this.string('vramSizeLabel');
			}
			
			updateContextDisplay() {
				elements.contextValue.textContent = `${this.format(this.contextWindow)} tokens`;
			}
			
			calculate() {
				const bytesPerParam = quantizationBits[this.quantization] / 8;
				const kvQuantBits = this.kvCacheQuant === 'same' ? 
					quantizationBits[this.quantization] : quantizationBits[this.kvCacheQuant];
				const bytesPerKvElement = kvQuantBits / 8;
				
				let overheadGB = 1.5;
				let availableVram = 0;
				let overheadMsg = "";

				if (this.gpuType === 'discrete') {
					overheadGB = 1.5;
					availableVram = this.vramSize - overheadGB;
				} else if (this.gpuType === 'soc') {
					// Apple Silicon: ~75% available for GPU
					availableVram = this.vramSize * 0.75;
					overheadGB = this.vramSize - availableVram;
					overheadMsg = "Reserved (25%)";
				} else if (this.gpuType === 'snapdragon') {
					// Snapdragon/Windows SoC: ~50% available for GPU
					availableVram = this.vramSize * 0.50;
					overheadGB = this.vramSize - availableVram;
					overheadMsg = "Reserved (50%)";
				}

				const availableForUse = Math.max(0, availableVram);
				
				let maxParams = 0;
				let estimatedArchitecture = { layers: 0, hidden: 0 };
				
				for (let i = 0; i < 5; i++) {
					const kvCache = estimatedArchitecture.layers ?
						(2 * estimatedArchitecture.layers * estimatedArchitecture.hidden * this.contextWindow * bytesPerKvElement) / (1024 ** 3) : 0;
					
					const memoryForWeights = availableForUse - kvCache;
					
					if (memoryForWeights <= 0) {
						maxParams = 0;
						break;
					}
					
					maxParams = memoryForWeights / bytesPerParam;
					estimatedArchitecture = estimateArchitecture(maxParams);
				}
				
				const kvCacheGB = estimatedArchitecture.layers ?
					(2 * estimatedArchitecture.layers * estimatedArchitecture.hidden * this.contextWindow * bytesPerKvElement) / (1024 ** 3) : 0;
				
				const results = {
					totalVram: this.vramSize,
					overheadGB: overheadGB,
					overheadMsg: overheadMsg,
					availableVram: availableForUse,
					kvCacheGB: kvCacheGB,
					modelMemoryGB: Math.max(0, availableForUse - kvCacheGB),
					maxParams: maxParams,
					estimatedArchitecture: estimatedArchitecture
				};
				
				this.displayResults(results);
			}
			
			displayResults(results) {
				const t = text[this.language];
				
				if (results.modelMemoryGB > 0) {
					elements.resultValue.textContent = `${Math.floor(results.maxParams)}B`;
					elements.resultValue.className = 'result-value';
					
					const category = this.getModelCategory(results.maxParams);
					elements.resultCategory.textContent = `${category} ${t.categorySuffix} Estimated Architecture`;
					
					if (results.estimatedArchitecture) {
						elements.modelDetails.classList.remove('hidden');
						elements.layersValue.textContent = results.estimatedArchitecture.layers;
						elements.hiddenValue.textContent = results.estimatedArchitecture.hidden;
					} else {
						elements.modelDetails.classList.add('hidden');
					}
				} else {
					elements.resultValue.textContent = t.insufficient;
					elements.resultValue.className = 'result-value insufficient';
					elements.resultCategory.textContent = '';
					elements.modelDetails.classList.add('hidden');
				}
				
				const mbPerToken = (results.kvCacheGB * 1024 / this.contextWindow).toFixed(2);
				elements.metricsList.innerHTML = `
					<div class="metric-card">
						<div class="metric-label">${t.totalVram}</div>
						<div class="metric-value">${results.totalVram} GB</div>
					</div>
					<div class="metric-card">
						<div class="metric-label">${t.systemOverhead}</div>
						<div class="metric-value">-${results.overheadGB.toFixed(1)} GB</div>
						${results.overheadMsg ? `<div class="metric-detail">${results.overheadMsg}</div>` : ''}
					</div>
					<div class="metric-card">
						<div class="metric-label">${t.kvCacheMemory}</div>
						<div class="metric-value">-${results.kvCacheGB.toFixed(2)} GB</div>
						<div class="metric-detail">${mbPerToken} MB/token</div>
					</div>
					<div class="metric-card" style="border-left-color: var(--primary); border-left-width: 3px;">
						<div class="metric-label">${t.modelWeights}</div>
						<div class="metric-value" style="color: var(--primary);">${Math.max(0, results.modelMemoryGB).toFixed(2)} GB</div>
					</div>
				`;
				
				const warnings = [];
				if (results.kvCacheGB > results.availableVram * 0.5) {
					warnings.push(t.warningKvCache);
				}
				if (results.modelMemoryGB <= 0) {
					warnings.push(t.warningInsufficient);
				}
				
				if (warnings.length > 0) {
					elements.warningBox.innerHTML = warnings.map(w => `<p>${w}</p>`).join('');
					elements.warningBox.classList.remove('hidden');
				} else {
					elements.warningBox.classList.add('hidden');
				}
			}
			
			getModelCategory(params) {
				const t = text[this.language];
				if (params < 1) return t.categoryToy;
				if (params < 3) return t.categorySmall;
				if (params < 10) return t.categoryMedium;
				if (params < 20) return t.categoryLarge;
				if (params < 40) return t.categoryVeryLarge;
				return t.categoryMassive;
			}
			
			format(value, options = {}) {
				return value.toLocaleString(this.language === 'id' ? 'id-ID' : 'en-US', options);
			}
			
			string(key) {
				return text[this.language]?.[key] ?? key;
			}
			
			theme(themeName) {
				document.documentElement.className = themeName === 'auto' ? '' : themeName;
				elements.theme.value = themeName;
			}
			
			lang(language) {
				this.language = elements.language.value = document.documentElement.lang = language;
				
				Object.keys(text.en).forEach(key => {
					if (elements[key]) {
						elements[key].textContent = this.string(key);
					}
				});
				
				[...elements.theme.options].forEach(option => {
					option.textContent = this.string(option.value + 'Theme');
				});
				
				elements.formulasSection.innerHTML = this.string('formulas');
				elements.architectureSection.innerHTML = this.string('architecture');
				elements.sourcesText.innerHTML = this.string('sources');
				
				this.updateVramDisplay();
				this.updateContextDisplay();
				this.calculate();
			}
		}
		
		new LLMCalculator();
	</script>
</body>
</html>
